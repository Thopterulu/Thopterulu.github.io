"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1628],{1135:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"learning-languages/rust","title":"Rust","description":"Memory Safety","source":"@site/docs/learning-languages/rust.md","sourceDirName":"learning-languages","slug":"/learning-languages/rust","permalink":"/docs/learning-languages/rust","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Python","permalink":"/docs/learning-languages/python"},"next":{"title":"Zig","permalink":"/docs/learning-languages/zig"}}');var t=r(4848),i=r(8453);const l={},o="Rust",a={},c=[{value:"Memory Safety",id:"memory-safety",level:2},{value:"The Ownership System",id:"the-ownership-system",level:3},{value:"Borrowing and References",id:"borrowing-and-references",level:3},{value:"The Borrowing Rules",id:"the-borrowing-rules",level:3},{value:"Lifetimes",id:"lifetimes",level:3},{value:"Smart Pointers",id:"smart-pointers",level:3},{value:"Key Benefits",id:"key-benefits",level:3},{value:"Advanced Topics",id:"advanced-topics",level:3},{value:"references",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"rust",children:"Rust"})}),"\n",(0,t.jsx)(n.h2,{id:"memory-safety",children:"Memory Safety"}),"\n",(0,t.jsxs)(n.p,{children:["Rust achieves memory safety through a combination of ",(0,t.jsx)(n.strong,{children:"ownership"}),", ",(0,t.jsx)(n.strong,{children:"borrowing"}),", and ",(0,t.jsx)(n.strong,{children:"lifetimes"})," - all enforced at compile time without runtime overhead. This gives you both safety AND performance, eliminating the traditional trade-off between garbage collected languages and manual memory management."]}),"\n",(0,t.jsx)(n.h3,{id:"the-ownership-system",children:"The Ownership System"}),"\n",(0,t.jsxs)(n.p,{children:["Every value in Rust has a single ",(0,t.jsx)(n.strong,{children:"owner"}),". When the owner goes out of scope, the value is automatically cleaned up. This prevents:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory leaks"})," - values are always cleaned up"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Double-free errors"})," - values can only be freed once"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use-after-free bugs"})," - you can't access moved values"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let s1 = String::from("hello");\n    let s2 = s1; // s1 is "moved" to s2\n\n    // println!("{}", s1); // This would cause a compile error!\n    println!("{}", s2); // This works fine\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"borrowing-and-references",children:"Borrowing and References"}),"\n",(0,t.jsxs)(n.p,{children:["Instead of transferring ownership, you can ",(0,t.jsx)(n.strong,{children:"borrow"})," values:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fn main() {\n    let s1 = String::from(\"hello\");\n    let len = calculate_length(&s1); // Borrow s1\n    println!(\"Length of '{}' is {}\", s1, len); // s1 is still valid!\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n} // s goes out of scope but doesn't drop the String (it's borrowed)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"the-borrowing-rules",children:"The Borrowing Rules"}),"\n",(0,t.jsx)(n.p,{children:"Rust enforces these rules at compile time:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["You can have either ",(0,t.jsx)(n.strong,{children:"one mutable reference"})," OR ",(0,t.jsx)(n.strong,{children:"any number of immutable references"})]}),"\n",(0,t.jsx)(n.li,{children:"References must always be valid (no dangling pointers)"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let mut s = String::from("hello");\n\n    let r1 = &s; // immutable borrow\n    let r2 = &s; // another immutable borrow - OK!\n\n    // let r3 = &mut s; // This would fail - can\'t have mutable and immutable borrows\n\n    println!("{} and {}", r1, r2);\n    // r1 and r2 are no longer used after this point\n\n    let r3 = &mut s; // Now this is OK\n    println!("{}", r3);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"lifetimes",children:"Lifetimes"}),"\n",(0,t.jsx)(n.p,{children:"Lifetimes ensure that references are valid for as long as needed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The lifetime annotation ",(0,t.jsx)(n.code,{children:"'a"})," tells Rust that the returned reference will live as long as the shorter of the two input references."]}),"\n",(0,t.jsx)(n.h3,{id:"smart-pointers",children:"Smart Pointers"}),"\n",(0,t.jsx)(n.p,{children:"Rust provides smart pointers for more complex memory management:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"Box<T>"})})," - Heap allocation with single ownership"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"Rc<T>"})})," - Reference counting for shared ownership"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"Arc<T>"})})," - Atomic reference counting for thread-safe sharing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"RefCell<T>"})})," - Interior mutability with runtime borrow checking"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::rc::Rc;\n\nfn main() {\n    let data = Rc::new(String::from("shared data"));\n    let data1 = Rc::clone(&data);\n    let data2 = Rc::clone(&data);\n\n    println!("Reference count: {}", Rc::strong_count(&data)); // Prints 3\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zero-cost abstractions"})," - No runtime overhead for safety"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prevents data races"})," - Compile-time guarantee of thread safety"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No garbage collector"})," - Deterministic memory management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Memory safety without ",(0,t.jsx)(n.code,{children:"unsafe"})]})," - Most code can be written safely"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Interior mutability patterns"})," - ",(0,t.jsx)(n.code,{children:"RefCell"}),", ",(0,t.jsx)(n.code,{children:"Cell"}),", ",(0,t.jsx)(n.code,{children:"Mutex"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["The ",(0,t.jsx)(n.code,{children:"unsafe"})," keyword"]})," - When and how to use it responsibly"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RAII (Resource Acquisition Is Initialization)"})," - Automatic resource cleanup"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Concurrent programming"})," - ",(0,t.jsx)(n.code,{children:"Arc"}),", ",(0,t.jsx)(n.code,{children:"Mutex"}),", channels"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"references"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://pragprog.com/titles/hwrust/hands-on-rust/",children:"rust from base to game2D"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://doc.rust-lang.org/book/",children:"The Rust Programming Language (The Book)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://doc.rust-lang.org/nomicon/",children:"Rustonomicon - The Dark Arts of Advanced Rust"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var s=r(6540);const t={},i=s.createContext(t);function l(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);